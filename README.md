# Библиотека светового канала для ESP32 K-018

Библиотека предназначена для организации простого одностороннего или двустороннего обмена данными между микроконтроллерами через световой канал. Передатчик управляет светодиодом или лазерным диодом, а приёмник использует фоторезистор (LDR) на плате ESP32 K-018. Код адаптирован под Arduino Core for ESP32 и может использоваться и на других платформах, поддерживаемых Arduino API.

## Аппаратные требования

- **Плата:** ESP32 K-018 (или аналогичная с доступом к ADC).
- **Излучатель:** высоко яркий LED или лазерный модуль, подключённый к `TX_PIN` (по умолчанию GPIO13).
- **Приёмник:** фоторезистор с резистивным делителем на входе `RX_PIN` (по умолчанию GPIO34). Рекомендуем делитель 10 кОм – 100 кОм.
- **Питание:** стабильное 5 В для излучателя и 3.3 В для делителя фоторезистора.
- **Общие провода:** земля передатчика и приёмника должна быть общей.

### Схема включения фоторезистора

```
3.3V ─┬─── LDR ───┬─> к ADC (GPIO34)
      │           │
      └─ 10 kΩ ───┘
          │
         GND
```

Меняя номинал резистора, добейтесь, чтобы при освещении фотодатчика напряжение на ADC заметно отличалось от уровня в темноте (разница > 800 шагов ADC).

## Структура проекта

- `led-lib.h / led-lib.cpp` — основной класс `LedIntr` для передачи и приёма битовых кадров по световому каналу.
- `Arduino-lib.h` — адаптер `ArduinoAdapter`, связывающий интерфейс `IGpioAdapter` со стандартным Arduino API.
- `sketch_4.ino` — минимальный пример для Arduino UNO/Nano: передача текста через LED (без приёма).
- `esp32_k018.ino` — пример для ESP32 K-018: двусторонний обмен с калибровкой фоторезистора на входе ADC.

## Быстрый старт (ESP32 K-018)

1. Скопируйте папку с библиотекой в `Documents/Arduino/libraries/` (либо подключите файлы к проекту PlatformIO).
2. Запустите Arduino IDE, откройте пример `esp32_k018.ino`.
3. В меню **Tools → Board** выберите `ESP32 Dev Module` (или профиль вашей платы K-018), укажите правильный COM-порт.
4. Подключите оборудование:
   - `TX_PIN` (GPIO13) → через резистор 220–330 Ω к аноду светодиода/управлению лазером, катод на GND.
   - `RX_PIN` (GPIO34) → точка делителя фоторезистор + резистор 10 кОм к земле, верх делителя на 3.3 В (см. схему выше).
   - Не забудьте общий GND между узлами.
5. Загрузите скетч в плату. После перезагрузки в Serial Monitor (115200 бод) появится сообщение `--- ESP32 LED link ready ---` и рассчитанный порог ADC.
6. Введите текст в Serial Monitor и отправьте — ESP32 отправит данные светом и попытается принять ответ световым каналом.

### Что смотреть и как тестировать

- Во время калибровки откройте/закройте датчик светом и убедитесь, что порог (`Threshold`) находится примерно посередине между ярким и тёмным значениями.
- Для диагностики можно временно добавить `Serial.println(analogRead(RX_PIN));` в `loop()` и наблюдать уровень освещённости.
- Если передача/приём нестабильны, увеличьте `BIT_US` (замедлите обмен) и/или `setSamplesPerBit()`.

## Алгоритм работы

### Передача

- Используется условное «UART-подобное» кадрирование: стартовый бит `0`, далее 8 данных (LSB first) и стоповый бит `1`.
- Продолжительность одного бита задаётся параметром `bitDurationUs` (по умолчанию 1000 мкс ≈ 1 кГц).
- Класс `LedIntr` управляет линией через `IGpioAdapter::pinWrite`, что облегчает портирование.

### Приём

- Чтение значения с фоторезистора происходит через `analogRead` с усреднением (`samplesPerBit`).
- Порог сравнения `_threshold` отделяет уровни «свет»/«темнота».
- Поиск стартового бита выполняется по последовательности низких значений. После синхронизации биты считываются через одинаковые интервалы.

## Настройка приёмника

### Калибровка порога

```cpp
LedIntr dev(&adapter, TX_PIN, RX_PIN, 1200);
dev.setSamplesPerBit(6);
delay(500);             // стабилизация
dev.autoCalibrate(400, 1000);
Serial.println(dev.threshold());
```

- `autoCalibrate(sampleCount, sampleDelayUs)` измеряет диапазон значений и выставляет порог по середине.
- Во время калибровки желательно, чтобы на фоторезистор попадал минимальный и максимальный возможный свет. Для точной настройки подсветите датчик вручную и затем закройте его.
- Порог можно задать вручную через `setThreshold(value)`.

### Усреднение и скорость

- `setSamplesPerBit(n)` задаёт количество измерений на бит. При увеличении устойчивость к шуму растёт, но максимальная скорость падает.
- `setBitDuration(us)` управляет длительностью бита. Для ESP32 K-018 стабильная работа достигается при 800–2000 мкс на бит (500–1250 бод) с типовым фоторезистором.

## Пример использования (ESP32, файл `esp32_k018.ino`)

```cpp
ArduinoAdapter adapter;
constexpr int TX_PIN = 13;
constexpr int RX_PIN = 34;
constexpr unsigned long BIT_US = 1200;
LedIntr dev(&adapter, TX_PIN, RX_PIN, BIT_US);

void setup() {
  Serial.begin(115200);
  pinMode(TX_PIN, OUTPUT);
  digitalWrite(TX_PIN, LOW);
  dev.setSamplesPerBit(6);
  delay(500);
  dev.autoCalibrate(400, 1000);
  Serial.println("--- ESP32 LED link ready ---");
  Serial.print("Threshold: ");
  Serial.println(dev.threshold());
}

void loop() {
  if (Serial.available()) {
    String input = Serial.readStringUntil('\n');
    dev.send(input + '\n');
  }

  String received;
  if (dev.receiveMessage(received, 64, 2)) {
    Serial.print("RX: ");
    Serial.println(received);
  }
}
```

### Быстрый тест для Arduino UNO (файл `sketch_4.ino`)

Скетч демонстрирует передачу текста через LED на цифровом выводе 13:

```cpp
ArduinoAdapter adapter;
LedIntr dev(&adapter, 13, -1, 100);

void setup() {
  pinMode(13, OUTPUT);
  Serial.begin(115200);
}

void loop() {
  if (Serial.available() > 0) {
    String input = Serial.readStringUntil('\n');
    dev.send(input);
  }
}
```

### Обработка приёма в отдельной задаче

Для непрерывного приёма можно создать FreeRTOS-задачу (ESP32):

```cpp
void receiverTask(void*) {
  dev.receiveLoop(Serial);
}

void setup() {
  // ... инициализация ...
  xTaskCreatePinnedToCore(receiverTask, "rx", 4096, nullptr, 1, nullptr, 1);
}
```

Метод `receiveLoop()` внутри содержит бесконечный цикл с вызовом `yield()` для ESP32, поэтому задача не блокирует планировщик.

## API справочник

### Класс `LedIntr`

| Метод | Описание |
|-------|----------|
| `LedIntr(IGpioAdapter*, int txPin, int rxPin, unsigned long bitDurationUs)` | Создаёт экземпляр. `txPin`/`rxPin` могут быть `-1`, если передача или приём не используются. |
| `void send(const String& text)` | Отправляет строку с кадрированием (добавьте `\n`, если нужен маркер конца). |
| `void setBitDuration(unsigned long bitDurationUs)` | Настройка длительности бита в микросекундах. |
| `unsigned long bitDuration() const` | Возвращает текущую длительность бита. |
| `void setThreshold(uint16_t threshold)` | Устанавливает порог яркости вручную. |
| `uint16_t threshold() const` | Возвращает текущий порог. |
| `void setSamplesPerBit(size_t samples)` | Количество измерений ADC на один бит. Минимум 1. |
| `size_t samplesPerBit() const` | Текущее количество измерений. |
| `void autoCalibrate(size_t sampleCount, unsigned long sampleDelayUs)` | Автоматически рассчитывает порог. |
| `bool receiveMessage(String& out, size_t maxChars, unsigned long startTimeoutMs)` | Пытается считать до `maxChars` символов. Возвращает `true`, если хотя бы один символ принят. |
| `void receiveLoop(Stream& output)` | Блокирующий цикл приёма; печатает символы в `Stream` (по умолчанию `Serial`). Подходит для отдельной задачи. |

### Интерфейс `IGpioAdapter`

| Метод | Назначение |
|-------|------------|
| `pinWrite(int pin, bool value)` | Установка уровня на выводе. |
| `pinRead(int pin)` | Чтение цифрового уровня (не используется в текущей версии). |
| `delay(unsigned long ms)` | Задержка в миллисекундах. |
| `delayMicro(unsigned long us)` | Задержка в микросекундах. |

Реализация `ArduinoAdapter` перенаправляет вызовы к стандартным `digitalWrite`, `delay`, `delayMicroseconds` и т.д.

## Практические советы

- Разместите фоторезистор в экранированной трубке, чтобы исключить паразитную засветку.
- Для повышенной дальности используйте лазерный диод и фотодиод с операционным усилителем. Код останется тем же — понадобится лишь калибровать порог.
- Контролируйте насыщение АЦП. Если значения близки к 0 или 4095 всё время, измените номинал резистора или расстояние.
- При увеличении скорости уменьшайте `samplesPerBit`, иначе усреднение займёт больше времени, чем длится бит.
- Для отладки выведите `analogRead` в Serial и убедитесь, что приёмник видит изменение уровня.

## Лицензия

Проект распространяется без указания лицензии. Добавьте собственную лицензию при необходимости.
